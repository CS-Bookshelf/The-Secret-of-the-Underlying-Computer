
# 📘 1.2 컴파일러는 무엇을 하는가

## 1.2.1 - 컴파일러는 특별한 존재가 아니다

컴파일러는 **고수준 언어**(예: C, Java)를 **저수준 언어**(예: 어셈블리어나 기계어)로 번역하는 일반적인 프로그램이다.  
그저 **텍스트를 처리하는 프로그램(text processor)** 또는 **번역기(translator)**일 뿐이다.

- 컴파일 과정 요약:

```

코드 작성 → 텍스트 파일(소스 코드) → 컴파일러 → 실행 파일

````

<br>

## 1.2.2 - 어휘 분석: 토큰 추출하기

컴파일러는 소스 코드를 읽으면서 의미 있는 최소 단위인 **토큰(Token)**을 추출한다.  
이 과정이 **어휘 분석(Lexical Analysis)**이다.

예시 코드:
```c
int a = 1;
````

토큰 추출 결과:

```
T_Keyword      int  
T_Identifier   a  
T_Assign       =  
T_Int          1  
```

* 왼쪽: 토큰의 종류
* 오른쪽: 실제 값

<br>

## 1.2.3 - 구문 분석: 문법 검사

**구문 분석(Parsing)** 단계에서는 토큰들이 **문법적으로 유효한 구조**인지 확인한다.
문법에 어긋나는 경우, **Syntax Error**가 발생한다.

이 과정에서는 **구문 트리(Parse Tree)** 또는 **구문 분석 트리**가 생성된다.
→ 토큰을 문법 규칙에 따라 계층 구조로 표현한 트리이다.

<br>

## 1.2.4 - 의미 분석: 논리적 오류 검사

구문이 맞더라도 **의미적으로 잘못된 코드**는 존재할 수 있다.
예를 들어, 선언하지 않은 변수를 사용하는 경우가 그렇다.

이 단계에서는 \*\*의미 분석(Semantic Analysis)\*\*을 통해 구문 트리를 검사하고, **타입 오류**나 **정의되지 않은 참조** 등을 찾아낸다.

<br>

## 1.2.5 - 중간 코드 생성: 플랫폼 독립적 표현

\*\*중간 코드(Intermediate Representation, IR)\*\*는 컴파일러가 실제 기계어로 번역하기 전 생성하는 **플랫폼에 독립적인 코드**이다.
의미 분석이 완료된 구문 트리를 기반으로 생성된다.

예시 중간 코드:

```
a = 1  
b = 2  
goto B  
A: b = b - 1  
B: if a < b goto A
```

<br>

## 1.2.6 - 코드 생성 및 링크

중간 코드를 바탕으로 **어셈블리어 → 기계어**로 번역하는 과정이 \*\*코드 생성(Code Generation)\*\*이다.

예: GCC 컴파일러를 사용한 경우

```
code.c → 컴파일 → code.o (Object File)
```

여러 개의 소스 파일이 있을 경우, 각각의 오브젝트 파일을 하나로 합쳐야 실행 가능하다.
이 과정이 \*\*링크(Link)\*\*이며, \*\*링커(Linker)\*\*가 이를 수행한다.

예:

```
main.o + util.o → main.exe
```

<br>

## 핵심 요약

| 단계 | 이름       | 설명                 |
| -- | -------- | ------------------ |
| 1  | 어휘 분석    | 토큰 단위로 코드 쪼개기      |
| 2  | 구문 분석    | 문법 구조 확인 및 트리 생성   |
| 3  | 의미 분석    | 타입 및 참조 오류 검증      |
| 4  | 중간 코드 생성 | 플랫폼 독립적인 중간 코드 생성  |
| 5  | 코드 생성    | 실제 기계어 또는 어셈블리어 생성 |
| 6  | 링크       | 여러 오브젝트 파일을 하나로 병합 |

```

---

## 1.2.1 - 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다.

컴파일러 : 고수준 언어를 저수준 언어로 번역하는 프로그램.

<aside>
💡

코드 → 텍스트 파일 형태 (소스 파일) → 컴파일러 → **실행 파일 형태**.

</aside>

컴파일러 : 번역기, 텍스트 처리 프로그램 (text processor) 

<br>

## 1.2.2 - 각각의 토큰 추출하기

```python
T_Keyword      int
T_Identifier   a
T_Assign       =
T_Int          1
...
```

→ 왼쪽 열은 토큰 의미, 오른쪽은 토큰의 값

### **어휘 분석 (lexical analysis)**

⇒ 소스 코드를 돌아다니며 모든 토큰을 찾아낸다

<br> 

## 1.2.3 - 토큰이 표현하고자 하는 의미

### 해석(parsing)

구문을 확인하며 앞 뒤에 맞게 필요한 토큰이 아니라면 문법 오류 (sytax error)를 보고한다. 아니면 계속 처리 

### 구문 분석

구문 규칙에 따라 토큰 해석 → 트리 생성

<br> 

## 1.2.4 - 생성된 구문 트리에 이상은 없을까?

### 의미 분석

구문 트리에 이상이 없는지 확인 후 컴파일 오류가 없다는 것이 증명되는 과정

<br> 

## 1.2.5 - 구문 트리를 기반으로 중간 코드 생성하기

### 중간 코드 (Intermediate Representation Code, IR Code)

→ 의미 분석 후에 구문 트리를 탐색한 결과를 바탕으로 생성.

```python
	a = 1
	b = 2
	goto B
A: b = b - 1
B: if a < b goto A
```

<br> 

## 1.2.6 - 코드 생성

컴파일러가 하는 일

<aside>
💡

중간 코드 → 어셈블리어 코드 → 기계 명령어

</aside>

예시: GCC 컴파일러

code.c → 컴파일 → code.o object 파일 생성

소스 파일이 여러 개 → object 파일 또한 여러 개

⇒ 이를 하나로 합쳐주는 무언가가 필요하다

>> **링크 (Link)** ; object 파일 병합 과정 ⇒ 링커 (linker) 가 담당.
