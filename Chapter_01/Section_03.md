# Section3 - 링커의 말할 수 없는 비밀 

### 외부 코드가 제공되는 형태

- 정적 라이브러리 (static library)
- 동적 라이브러리 (dynamic library)

C/C++ 에서 **“undefined reference to *** “** 오류 해결 방법

⇒ 링커와 관련 있는 것들
<br> 

## 1.3.1 - 링커는 이렇게 일한다

컴파일러가 생성한 objec 파일들을 하나의 실행 파일로 묶어서 만든다. 

### 심벌 해석 (symbol resolution)

종속성이 올바르게 설정 돼 있는지(인터페이스 구현이 종속된 모듈에서 사용 가능한 지) 확인 하여 연결

### 실행 파일 생성

링크 과정을 마친 후 최종적으로 실행 파일 (.exe)가 생성된다.

### 재배치 (relocation)

특정 소스 파일에서 다른 모듈에 정의 되어 있는 걸 참조할 때 어느 메모리 주소에 위치할 지 모르기 때문에 N으로 표시 후 링크 과정에서 표시들을 확인하고 실행 파일을 생성하는 과정에서 참조하는 것의 주소를 확인 후 N을 실제 메모리 주소로 대체한다.
<br> 

## 1.3.2 - 심벌 해석: 수요와 공급

### 심벌 (symbol) 이란?

→ 전역 변수, 함수의 이름을 포함하는 모든 변수 이름.

지역 변수는 모듈 내에서만 사용 돼 외부 모듈에서 참조 X

예시)

소스 파일 func.c

```python
int g_a = 1;                // 전역 변수

extern int g_e;             // 외부 변수

int func_a(int x, int y);   // 함수 참조

// 함수 구현
int func_b()
{
    int m = g_a + 2;
    
    return func_a(m + g_e);
}
```

→ g_a, func_b 심벌 정의

→ g_e, func_a 외부 심벌 참조 중

컴파일러가 생성하는 명령어 실행 데이터는 object 파일에 포함된다. 

### object 파일

- 명령어 부분 : 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분.
- 데이터 부분 : 소스 파일의 전역 변수가 저장되는 부분.
    - 아마 저자는 초기화된 전역 변수가 저장되는 .data 영역을 말하고 싶은 것 같다.

참고) 로컬 변수는 프로그램이 실행된 후 스택 영역에서 생성되고 사용하면 제거 돼 object 파일에는 저장 X 

### 심벌 테이블 (symbol table)

- 내가 정의한 심벌, 다른 모듈에서 사용 가능한 것
- 내가 사용하는 외부 심벌

→ 이는 컴파일러가 하는 작업 ⇒ 오브젝트 파일에 저장된다.

### func.o (오브젝트 파일)

- 코드 영역 → func_b() 함수
- 데이터 영역 → g_a (초기화 된 전역 변수)
- 심벌 테이블 → 정의한 심벌, 외부 심벌 저장

### 심벌 해석

링커는 공급이 수요를 충족하는지 확인하여야 한다.

→ 각 오브젝트 파일에서 사용할 외부 심벌이 심벌 테이블에서 유일한 정의 (unique definition)을 발견 가능한지 확인하는 작업. 

⇒ 사용하고자 하는 심벌이 심벌 테이블 정의 돼 있어야만 사용 가능하다. 

```python
void func();

void main() 
{
    func();
}
```

→  undefined reference to ‘func’ 오류 발생.

func는 참조 됐지만 정의되지 않는 심벌이다. → 링커가 func 함수에 대한 정의를 못 찾음 (내용이 없음)

<br>

## 1.3.3 - 정적 라이브러리, 동적 라이브러리, 실행 파일

### 정적 라이브러리

기능이 많은 유틸리티 함수들의 코드를 별도로 컴파일 하여 패키지로 묶고, 구현된 모든 함수의 선언을 포함하는 헤더 파일. 

→ .lib (window), .a (linux)

소스 파일 별로 각각 컴파일한 후 링크 해서 정적 라이브러리로 생성 가능하다.

⇒ 이후 실행 파일을 생성 할 때는 자신의 코드만을 컴파일 한다. 정적 라이브러리의 경우 링크 과정에서 그대로 실행 파일에 복제됨. → 컴파일 속도가 빠르다.

### 정적 링크

오브젝트 파일을 한 곳에 모아서 실행 파일을 만든다. → 실행 파일에도 동일하게 코드 영역, 데이터 영역이 존재한다.  특수 심벌 _start 에서 CPU가 프로그램을 실행하는 데 필요한 기계 명령어를 찾는다.

→ 이 명령어 실행 후에 프로그래머가 작성한 main 함수 실행

### 문제점

정적 라이브러리를 사용하는 실행 파일이 많으면 많을 수록 중복된 데이터가 많아져 디스크, 메모리 낭비가 심해진다. 

모든 내용에 종속성이 있다면 정적 라이브러리의 코드가 변경될 때마다 종속된 프로그램 또한 다시 컴파일이 필요하다

⇒ 이 문제는 동적 라이브러리로 해결이 된다. 

### 동적 라이브러리

== 공유 라이브러리 (shared library) or 동적 링크 라이브러리 (dynamic linked library)

예) DLL 파일 (window), libXXX.so (linux)  

→ 윈도우 시스템에서는 이를 매우 많이 활용.

예시) 소스 파일 a.c, b.c → foo 라는 이름의 동적 라이브러리 생성을 원하면

⇒ $ gcc -shared -fPIC -o [libfoo.so](http://libfoo.so) a.c b.c 

이렇게 사용하면 된다.

⇒ 참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보와 같은 필수 정보만 실행 파일에 포함.

### 정적 VS. 동적

정적 라이브러리: 코드 영역과 데이터 영역을 모두 한데 묶어 실행 파일에 복사

동적 라이브러리: 필수 정보만 실행 파일에 포함.

### 동적 링크 (dynamic linker)

참조된 동적 라이브러리의 필수 정보가 저장된다. 

- 프로그램이 메모리에 적재(loading) 될 때 동적 링크가 진행
    - loading: 실행 파일을 실행하기 위해 디스크에서 읽어 메모리의 특정 영역으로 이동시키는 과정 (loader 실행)
    - 실행 파일 로딩 후 로더는 실행 파일이 동적 라이브러리에 의존하는 지 여부를 확인.
    - 필요하다면 동적 링커(dynamic linker) 라는 별도의 프로세스 실행
        - → 동적 라이브러리 존재 여부, 위치, 심벌의 메모리 위치 확인 후 링크 과정 마무리.
    - 문제 발생시 오류 표시
    - 적재 중 동적 링크를 사용하려면 실행 파일이 어떤 동적 라이브러리를 참조하는지 명시적으로 알려줘야 함.
        - 예시) $ gcc -o pro main.c /path/to/libfoo.so
        - 이와 같은 방식으로 생성된 실행 파일은 로딩 시점에 동적 링크 발생

- 프로그램이 먼저 실행된 후, 프로그램의 실행 시간(runtime) 동안 코드가 직접 동적 링크 실행 가능. (실행시간 동적 링크)
    - 실행 시간(runtime): CPU가 프로그램을 실행하기 시작한 시점부터 실행이 완료 돼 프로그램이 종료된 시점까지 시간.
    - 실행 파일 내부에 동적 라이브러리 정보 저장 X
    - 코드에 특정 API를 사용해 필요 시에 동적 라이브러리를 직접 동적으로 적재할 수 있다.
<br>

## 1.3.4 - 동적 라이브러리의 장단점

### 동적 라이브러리

### <장점>

의존하는 프로그램 수 상관 없이 동적 라이브러리의 복사본 하나만 저장.

→ 공유 라이브러리라고도 함. 메모리 적재와 디스크 저장에 필요한 리소스를 절약 가능.

동적 라이브러리의 코드가 수정 되어도 해당 동적 라이브러리만 다시 컴파일 하면 된다.

→ 프로그램 업그레이드, 버그 수정 쉽게 만듦.

동적 라이브러리의 방식에 따라 플러그인을 적재해 프로그램 사용 가능.

→ 새로운 동적 라이브러리 제공 ; 플러그인 구현 방법.

여러 언어 혼합해 개발하기 유용

→ 파이썬의 빠른 개발 속도 & C/C++ 성능 함께 사용 가능 ; 더 높은 성능이 요구되는 부분은 동적라이브러리를 통해 C/C++ 로 작성된 함수를 직접 호출 가능하다.

→ 코드의 재사용 효율 ↑

### <단점>

정적 링크를 사용할 때보다 성능이 약간 떨어짐. → 프로그램이 적재되는 시간 또는 실행 시간에 링크되기 때문

동적 라이브러리의 코드는 임의의 메모리 절대 주소로 참조할 수 없다. → 특정 메모리 주소와 독립적으로 동작하기 때문 (위치 독립 코드), 메모리에 단 하나의 복사본만 존재하고 해당 코드는 여러 프로세스가 공유 가능하기 때문.

```cpp
call 0x4004d6 # foo 함수 호출
```

→ 함수 주소 값 0x4004d6: 변경 불가능한 절대 값.
