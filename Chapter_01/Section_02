아래는 주어진 내용을 **가독성 높게**, **논리 흐름에 따라**, **필요한 보충 및 오탈자 수정**을 거쳐 정리한 버전입니다. Markdown 형식으로 구성되어 있으므로 README나 노트로 활용하기에도 적합합니다.

---

# 📘 1.2 컴파일러는 무엇을 하는가?

## 1.2.1 - 컴파일러는 특별한 존재가 아니다

* **컴파일러**란?
  → 고수준 언어(예: C, Python)를 \*\*저수준 언어(기계어)\*\*로 번역하는 **일반적인 프로그램**이다.

* **컴파일 과정 요약**:

  ```
  코드 작성 → 텍스트 파일(소스 코드) → 컴파일러 → 실행 파일
  ```

* 컴파일러는 본질적으로 **텍스트 처리기(text processor)** 혹은 \*\*번역기(translator)\*\*일 뿐이다.

---

## 1.2.2 - 소스 코드에서 토큰 추출

* 소스 코드 예시:

  ```c
  int a = 1;
  ```

* **어휘 분석 (Lexical Analysis)**:
  → 소스 코드를 순회하며 \*\*토큰(token)\*\*을 하나씩 추출

  ```text
  T_Keyword      int
  T_Identifier   a
  T_Assign       =
  T_Int          1
  ```

* 토큰: 소스 코드를 이루는 최소 단위의 의미 있는 조각
  (왼쪽은 토큰의 타입, 오른쪽은 실제 값)

---

## 1.2.3 - 토큰의 문법적 의미 분석

* **구문 분석 (Parsing)**:
  → 토큰이 문법에 맞는 순서로 사용되었는지를 확인
  → 문법 오류(syntax error)가 있다면 컴파일 중단

* **구문 트리 (Parse Tree)**:
  → 토큰을 \*\*문법 규칙(grammar)\*\*에 따라 계층적으로 해석한 트리 구조

---

## 1.2.4 - 의미 분석 (Semantic Analysis)

* 구문 트리에는 문제가 없더라도, **의미상 문제가 있는지** 확인해야 한다.
* 예: 선언되지 않은 변수 사용, 타입 불일치 등

---

## 1.2.5 - 중간 코드 생성 (Intermediate Code Generation)

* 구문 및 의미 분석을 마친 후, 컴파일러는 \*\*중간 코드(IR: Intermediate Representation)\*\*를 생성한다.

* 예시:

  ```text
  a = 1
  b = 2
  goto B
  ```

A: b = b - 1
B: if a < b goto A

```

- 중간 코드는 기계어가 아니며, **추상적인 저수준 코드**이다.  
(플랫폼 독립적인 중간 단계)

---

## 1.2.6 - 최종 코드 생성 및 링크

- **코드 생성 (Code Generation)**:
- 중간 코드 → 어셈블리어 → 기계어(실행 가능한 바이너리)
- 예: `GCC` 컴파일러는 `code.c`를 `code.o`로 변환 (Object File)

- **링킹 (Linking)**:
- 여러 개의 오브젝트 파일을 하나로 결합
- 이 작업은 **링커(Linker)**가 수행한다.
- 예: `main.o`, `math.o` → `main.exe`

---

# ✅ 핵심 요약

| 단계 | 이름 | 역할 |
|------|------|------|
| 1 | 어휘 분석 | 토큰 추출 |
| 2 | 구문 분석 | 문법 구조 파악 |
| 3 | 의미 분석 | 논리 오류 검사 |
| 4 | 중간 코드 생성 | 추상적 실행 흐름 표현 |
| 5 | 코드 생성 | 실제 기계어로 번역 |
| 6 | 링크 | 여러 오브젝트 파일 통합 |

---

필요하면 각 단계별 그림이나 예제 코드를 시각적으로 첨부해도 좋습니다. 수정하거나 더 구체화하고 싶은 부분 있으면 말해 주세요!
```

