# Section1 - 여러분이 프로그래밍 언어를 발명한다면?

## 1.1.1 - 창세기: CPU는 똑똑한 바보

- CPU는 오직 0과 1(ON/OFF)만 이해하는 단순한 계산기
- 기능은 단순하지만, **연산 속도가 매우 빠르다**
- 초창기 인간과 CPU의 소통 방식:
    1. 인간이 CPU의 언어로 말함 (e.g. 펀치 카드)
    2. (후대 등장) CPU가 인간 언어를 이해하게 만드는 것

→ 초기에는 **기계어(binary)** 로만 소통했음

```
110101010101010
101001010101011
```
<img width="300" alt="image" src="https://github.com/user-attachments/assets/310fbc7d-073a-4a81-ac75-5f8eb13f1af7" />

<br>


## 1.1.2 - 어셈블리어 등장

- 기계어는 인간에게 너무 어렵고 비효율적
- CPU 명령어에 **기억하기 쉬운 이름(alias)** 을 붙인 언어 = 어셈블리어
- 어셈블리어는 기계어와 1:1 대응됨

```
sub $8, %rsp
mov $.LC0, %edi
call puts
```

- 어셈블리어 → 기계어로 번역하는 프로그램 = **어셈블러**

<br>

## 1.1.3 - 저수준 vs 고수준 언어

- 어셈블리어는 **저수준 언어 (low-level language)**:
    - 모든 세부 명령을 인간이 직접 작성해야 함
- 인간의 언어는 추상적이나, 저수준 언어는 **하나하나 구체적으로 지시**해야 함

> 예: “물 한 잔 주세요”
> 
> 
> → 저수준 언어 표현:
> 

```
1. 오른발 내딛기
2. 멈추기
3. 왼발 내딛기
...
```

→ 이런 반복/조건/함수를 추상화한 언어 필요

<br>


## 1.1.4 - 고급 프로그래밍 언어의 탄생

- 저수준 명령어에는 규칙과 패턴이 있음
- 이를 일반화하여 **조건문, 반복문, 함수** 등의 개념이 도입됨

```python
if 조건:
    실행문
else:
    다른 실행문

while 조건:
    반복 실행문

def 함수명(매개변수):
    실행문

```

→ 프로그래밍 언어가 점점 **사람의 사고방식**에 가까워짐

<br>

## 1.1.5 - 인셉션과 재귀: 코드의 본질

- if, while 등의 내부에는 또 다른 코드가 들어갈 수 있음 → **재귀적 구조**
- 대표적 예: 피보나치 수열

```python
def fib(n):
    if n <= 1: return n
    return fib(n-1) + fib(n-2)

```

- → 모든 프로그램은 이러한 **중첩된 구조 (syntax tree)** 로 표현 가능
![recursion tree](https://www.hello-algo.com/en/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png)

<br>

## 1.1.6 - 구문 트리와 번역

- 고급 언어로 작성된 코드는 내부적으로 **구문 트리(Syntax Tree)** 로 파싱됨

```
statement - if
          ├── condition
          └── block - if
                     ├── condition
                     └── block ..
```

→ 이 구문 트리를 기반으로 CPU가 이해할 수 있는 명령어로 **번역**


![recursion tree img](https://upload.wikimedia.org/wikipedia/commons/f/f7/RecursiveTree.JPG)

<br>

## 1.1.7 - 우수한 번역가: 컴파일러

- **컴파일러**: 고급 언어 → 저수준 언어(기계어)로 번역하는 프로그램
- 개발자는 이제 **사람 친화적인 언어로 프로그래밍** 가능

```
코드 → 컴파일러 → 실행 파일 → CPU 실행
```

<br>

## 1.1.8 - 해석형 언어와 가상 머신

- 실행 파일은 CPU마다 형식이 달라 **호환성 문제** 발생
- 이를 해결하기 위해 **중간 언어(바이트코드)** 와 **가상 머신(VM)** 개념 등장

```
코드 → 바이트코드 → 인터프리터(VM) → CPU

```

- Python, Java 등은 이 방식을 채택

<br>

## 요약 정리

| 계층 | 설명 |
| --- | --- |
| 기계어 | CPU가 직접 이해하는 언어 (0과 1) |
| 어셈블리어 | 기계어를 사람이 알아볼 수 있도록 문자로 표현 |
| 고급 언어 | if, while, 함수 등 인간 중심의 추상화 |
| 컴파일러 | 고급 언어 → 기계어로 번역 |
| 인터프리터 / VM | 중간 언어(바이트코드)를 해석하여 실행 |


<br> <br>
스위치를 조합하면 복잡한 불 논리 (boolean logic)을 표현 할 수 있다 → CPU 탄생

CPU → 0, 1 (on-off) 만을 이해할 수 있다.

<br>


